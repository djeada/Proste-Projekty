# Proste Projekty
Zbiór porad i zasobów dla początkujących programistów, zawierający szczegółowe wytyczne oraz przykłady realizacji projektów.

## Jak efektywnie rozpocząć swój pierwszy projekt?

* Kiedy rozpoczynamy naukę programowania, opanowanie *podstaw* pozwala zrozumieć takie elementy jak zmienne czy pętle, a ich brak prowadzi do trudności w rozwiązywaniu nawet prostych zadań; przykładem jest sytuacja, gdy nieznajomość instrukcji warunkowych uniemożliwia stworzenie kalkulatora.
* Inspiracja codziennymi problemami ułatwia wybór *tematu* projektu, podczas gdy brak kierunku skutkuje odkładaniem pracy; prostym przykładem może być stworzenie programu do zarządzania listą zakupów.
* Tworzenie unikalnych rozwiązań rozwija *oryginalność*, natomiast kopiowanie cudzych projektów ogranicza kreatywność; dobrym przykładem jest modyfikacja istniejącej gry, aby dodać nowe zasady lub tryby.
* Ocena własnych możliwości wspiera *realność* projektu, a jej brak prowadzi do frustracji i porzucenia pracy; przykładem może być wybór prostego kalkulatora zamiast od razu budowania pełnej aplikacji społecznościowej.
* Pobranie i konfiguracja *środowiska programistycznego* umożliwia sprawną pracę, a jego brak utrudnia pisanie i uruchamianie kodu; przykładem jest użycie VS Code zamiast edytora tekstowego bez wsparcia dla języka.
* Przygotowanie logicznej *struktury projektu* ułatwia zarządzanie plikami, a jej brak prowadzi do chaosu w kodzie; przykładem jest podział aplikacji na foldery „src”, „tests” i „docs”.
* Rozpoczęcie pracy nad *dokumentacją* wspiera czytelność projektu, a jej brak utrudnia innym zrozumienie jego działania; prostym przykładem jest dodanie pliku README.md z instrukcją uruchomienia.
* Wdrożenie *Git* zapewnia kontrolę wersji kodu, a jego brak utrudnia cofnięcie się do stabilnych rozwiązań; przykładem jest zapisanie każdej nowej funkcji w osobnym commicie.
* Krótka przerwa sprzyja *refleksji*, podczas gdy jej brak powoduje utratę świeżego spojrzenia; przykładem jest zauważenie prostego błędu po godzinnej przerwie od kodowania.
* Stopniowe dodawanie *funkcjonalności* zgodnie z listą zadań zapewnia systematyczny rozwój projektu, a brak planu prowadzi do chaotycznego kodu; przykładem jest implementacja logowania przed dodaniem panelu użytkownika.
* Regularne *testowanie* pozwala wykrywać błędy na wczesnym etapie, a jego brak skutkuje awariami podczas użycia; przykładem jest napisanie testów jednostkowych dla funkcji obliczającej podatek.
* Dokumentowanie zmian poprzez *commity* w Git ułatwia śledzenie postępów, a brak zapisów uniemożliwia powrót do starszej wersji; przykładem jest cofnięcie się do stabilnej wersji aplikacji sprzed wprowadzenia błędu.
* Korzystanie z internetowych *źródeł pomocy* przyspiesza rozwiązywanie problemów, a izolacja wydłuża proces nauki; przykładem jest znalezienie rozwiązania błędu składni na Stack Overflow.
* Udostępnienie *projektu* innym zwiększa jego użyteczność, a brak publikacji ogranicza zasięg; przykładem jest opublikowanie aplikacji na GitHub i uruchomienie jej na Heroku.
* Dzielenie się własnymi *osiągnięciami* buduje motywację, a brak prezentacji prowadzi do utraty satysfakcji; przykładem jest opowiedzenie znajomym o aplikacji ułatwiającej planowanie treningów.

## Tak zwane dobre praktyki programowania

Dobre praktyki programowania to zestaw wytycznych mających na celu poprawę jakości kodu i ułatwienie jego rozwoju, bez względu na język programowania. 

### Korzyści z dobrych praktyk

Stosowanie tych praktyk przynosi szereg korzyści, takich jak:

* Pisanie w sposób ułatwiający *czytelność* sprawia, że inni programiści mogą szybko zrozumieć kod, a jego brak prowadzi do długiego analizowania prostych fragmentów; przykładem jest stosowanie opisowych nazw funkcji zamiast jednoliterowych.
* Gdy kod jest napisany z myślą o łatwej *modyfikacji*, wprowadzanie zmian przebiega sprawnie, podczas gdy brak takiego podejścia wydłuża aktualizacje; przykładem jest możliwość szybkiego dodania nowej opcji do formularza dzięki modularnej strukturze.
* Zwięzła forma kodu wspiera *zmniejszenie objętości*, a jej brak powoduje powielanie tych samych rozwiązań w wielu miejscach; przykładem jest wykorzystanie funkcji pomocniczej zamiast kopiowania tego samego fragmentu kodu.
* W pracy zespołowej jasna *organizacja* kodu pozwala wielu osobom na wspólne rozwijanie projektu, a jej brak prowadzi do nieporozumień; przykładem jest przestrzeganie ustalonego stylu kodowania w repozytorium grupowym.
* Struktura wspierająca *testowanie* umożliwia szybkie wykrywanie błędów, a jej brak utrudnia sprawdzanie poprawności działania; przykładem jest łatwość napisania testów jednostkowych dla funkcji, gdy kod jest podzielony na małe moduły.

### Organizacja projektu

Aby efektywnie zarządzać projektem, warto stosować się do następujących zasad:

* Regularne korzystanie z *kontroli wersji* umożliwia śledzenie zmian i łatwe cofanie się do wcześniejszych etapów, a jej brak prowadzi do utraty postępów; przykładem jest użycie gałęzi „feature branch” do testowania nowej funkcji bez ryzyka uszkodzenia głównego kodu.
* Systematyczna *analiza* i poprawa istniejącego kodu pozwala zwiększyć wydajność i stabilność, podczas gdy brak przeglądu skutkuje nagromadzeniem błędów; przykładem jest refaktoryzacja funkcji na podstawie wyników testów jednostkowych.
* Tworzenie bieżącej *dokumentacji* ułatwia zrozumienie kodu w przyszłości, a jej brak powoduje konieczność czasochłonnej analizy; przykładem jest zapisanie instrukcji konfiguracji środowiska w pliku README.md.
* Dbałość o *czytelność* i spójny styl kodu ułatwia jego utrzymanie, a brak formatowania utrudnia współpracę; przykładem jest użycie narzędzia Black w Pythonie do automatycznego formatowania.
* Podział programu na *funkcje* i klasy upraszcza jego strukturę i wspiera ponowne wykorzystanie, podczas gdy brak modularności prowadzi do trudnego w utrzymaniu monolitu; przykładem jest osobna klasa do obsługi logowania w aplikacji.
* Świadome korzystanie z *zewnętrznego kodu* pozwala na jego bezpieczne dostosowanie, a kopiowanie bez zrozumienia prowadzi do błędów trudnych do naprawienia; przykładem jest adaptacja algorytmu z internetu do własnej bazy danych zamiast bezpośredniego wklejenia.
* Usuwanie *martwego kodu* zmniejsza ryzyko niepotrzebnego obciążenia i niejasności, a jego pozostawienie utrudnia analizę; przykładem jest eliminacja nieużywanych zmiennych po refaktoryzacji.
* Reagowanie na *ostrzeżenia kompilatora* pozwala wcześnie wykrywać problemy, a ich ignorowanie prowadzi do trudnych do znalezienia błędów; przykładem jest poprawienie ostrzeżenia o możliwej dereferencji pustego wskaźnika w C++.

### Zmienne

* Nadawanie opisowych *nazw zmiennym* sprawia, że kod staje się łatwiejszy do zrozumienia, a brak jasności prowadzi do pomyłek podczas dalszej pracy; przykładem jest użycie `total_salary` zamiast `x`.
* Konsekwentne stosowanie wybranej *konwencji nazewnictwa* zapewnia spójność projektu, a jej mieszanie utrudnia czytanie kodu; przykładem jest użycie `snake_case` we wszystkich funkcjach w Pythonie zamiast łączenia go z `camelCase`.
* Eliminowanie *zbędnych zmiennych* pozwala uprościć kod, podczas gdy ich nadmiar wprowadza chaos; przykładem jest zapisanie wyniku obliczenia bezpośrednio w instrukcji warunkowej zamiast tworzenia niepotrzebnej zmiennej pośredniej.
* Zachowanie *stałości znaczenia* zmiennej ułatwia śledzenie logiki, a zmiana jej przeznaczenia powoduje błędy trudne do wykrycia; przykładem jest niewykorzystywanie `suma` raz do sumy, a innym razem do liczby elementów.
* Ograniczenie *zmiennych globalnych* zmniejsza ryzyko nieoczekiwanych efektów ubocznych, a ich nadużycie utrudnia debugowanie; przykładem jest przekazywanie danych do funkcji przez argumenty zamiast odwoływania się do globalnego stanu.
* Deklarowanie *zmiennych* w miejscu ich pierwszego użycia poprawia czytelność i zmniejsza ryzyko błędów, a przedwczesne deklaracje mogą prowadzić do niepotrzebnego zajmowania pamięci; przykładem jest stworzenie zmiennej licznikowej dopiero wewnątrz pętli, w której jest używana.

### Warunki

* Pisanie warunków w sposób *prosty* poprawia ich czytelność, a nadmierna złożoność utrudnia zrozumienie logiki programu; przykładem jest podział długiego wyrażenia logicznego na dwie mniejsze funkcje pomocnicze.
* Zamiast głębokiego *zagnieżdżenia* instrukcji warunkowych lepiej stosować klauzule ochronne, ponieważ pozwalają one szybciej zakończyć funkcję, a brak takiego podejścia prowadzi do trudnych w śledzeniu bloków kodu; przykładem jest użycie `if not user: return` zamiast wielokrotnego `else`.
* Rozdzielenie *zadań* na osobne funkcje sprawia, że kod staje się modularny, podczas gdy wiele warunków pod rząd obniża przejrzystość; przykładem jest przeniesienie logiki walidacji formularza do osobnej funkcji.
* Wykorzystanie wyników *wartości logicznych* bezpośrednio w warunkach upraszcza kod, a ich dodatkowe porównywanie wydłuża zapis; przykładem jest zapis `if is_valid:` zamiast `if is_valid == True:`.
* Dodawanie *nawiasów* wokół warunków eliminuje wątpliwości co do kolejności działań, a ich brak może prowadzić do błędnej interpretacji; przykładem jest zapis `(a and b) or c` zamiast `a and b or c`.
* Formułowanie warunków w sposób *pozytywny* poprawia czytelność, podczas gdy złożone negacje wprowadzają zamieszanie; przykładem jest `if has_access:` zamiast `if not no_access:`.

### Funkcje

* Nadawanie funkcjom jasnych *nazw* pozwala od razu zrozumieć ich działanie, a brak tego prowadzi do mylącej interpretacji; przykładem jest `calculate_tax()` zamiast `processData()`.
* Funkcja o *jednoznacznym celu* jest łatwa do przetestowania i utrzymania, podczas gdy funkcja realizująca wiele zadań staje się trudna do analizy; przykładem jest oddzielenie walidacji danych od ich zapisu do bazy.
* Unikanie *mylących nazw* zapobiega błędnym oczekiwaniom, a nieadekwatne nazwy utrudniają debugowanie; przykładem jest niewłaściwe nazwanie funkcji `delete_user()` jako `update_user()`.
* Stosowanie zasady *DRY* ogranicza powtarzalność kodu, a jej brak prowadzi do nadmiarowych fragmentów trudnych w utrzymaniu; przykładem jest wydzielenie wspólnej walidacji formularza do jednej funkcji używanej w wielu modułach.
* Krótkie *funkcje* zwiększają czytelność i łatwość testowania, a długie definicje komplikują pracę; przykładem jest funkcja licząca średnią w kilku linijkach zamiast w kilkudziesięciu.
* Ukrywanie *implementacji* sprawia, że użytkownik funkcji widzi tylko jej efekt, a brak enkapsulacji zmusza do analizy wewnętrznej logiki; przykładem jest użycie publicznej funkcji `sort()` bez znajomości algorytmu sortowania.
* Optymalne *przekazywanie argumentów* przez referencję zwiększa wydajność, a kopiowanie dużych struktur danych spowalnia działanie programu; przykładem jest przekazanie listy do funkcji w Pythonie bez jej duplikowania.
* Zachowanie *spójności danych* między funkcjami minimalizuje ryzyko błędów, a brak tego prowadzi do niespójnych wyników; przykładem jest zapewnienie, że każda funkcja otrzymuje datę w tym samym formacie.
* Uwzględnianie *przypadków brzegowych* zwiększa odporność funkcji, a ich pominięcie prowadzi do awarii w nietypowych sytuacjach; przykładem jest obsługa pustej listy w funkcji obliczającej średnią.
* Unikanie *argumentów logicznych* poprawia przejrzystość, a ich stosowanie komplikuje logikę; przykładem jest zastąpienie funkcji `generateReport(isPDF)` dwiema funkcjami: `generatePdfReport()` i `generateHtmlReport()`.
* Ograniczenie liczby *argumentów* ułatwia zrozumienie funkcji, a ich nadmiar wymaga śledzenia wielu zależności; przykładem jest przekazanie obiektu konfiguracyjnego zamiast pięciu oddzielnych parametrów.
* Tworzenie *funkcji bez efektów ubocznych* poprawia przewidywalność programu, a modyfikowanie stanu globalnego prowadzi do trudnych do wykrycia błędów; przykładem jest zwracanie nowej listy zamiast zmiany istniejącej globalnej zmiennej.

### Klasy

* Nadawanie klasom jasnych *nazw* w formie rzeczowników poprawia ich czytelność, a brak tego wprowadza niejasność co do roli; przykładem jest `User` zamiast `ProcessData`.
* Tworzenie prostego interfejsu i *ukrywanie złożoności* sprawia, że klasa jest łatwa w użyciu, a brak tego czyni pracę z nią bardziej skomplikowaną niż manipulowanie danymi bezpośrednio; przykładem jest klasa `Database` oferująca metody `connect()` i `query()` zamiast ujawniania pełnych procedur połączenia.
* Stosowanie *enkapsulacji* chroni dane przed niepożądanymi zmianami, a jej brak prowadzi do naruszania logiki wewnętrznej obiektu; przykładem jest prywatne pole `balance` z metodami `deposit()` i `withdraw()` zamiast bezpośredniego dostępu.
* Odpowiednie *grupowanie danych* w klasie zwiększa spójność, a tworzenie klas-monolitów powoduje trudności w utrzymaniu; przykładem jest rozdzielenie `Order` i `Customer` zamiast łączenia wszystkich danych w jednej klasie.
* Unikanie *niepotrzebnych klas* pozwala zachować prostotę, a ich nadmiar prowadzi do przeintelektualizowanego projektu; przykładem jest użycie zwykłej funkcji do konwersji walut zamiast tworzenia pełnej klasy.
* Kontrolowanie *stanu obiektu* sprawia, że jego zachowanie jest przewidywalne, a brak tego utrudnia debugowanie; przykładem jest metoda `set_status("active")` działająca w sposób powtarzalny zamiast zmieniająca różne pola w tle.
* Zachowanie *spójności nazewnictwa funkcji* ułatwia rozumienie projektu, a brak jednolitości prowadzi do nieporozumień; przykładem jest używanie `to_json()` we wszystkich klasach zamiast raz `export()` a raz `convertToJson()`.
* Minimalizowanie *pustych pól* poprawia przejrzystość klas, a ich obecność zwiększa ryzyko błędów; przykładem jest rozdzielenie klas `Car` i `Bike` zamiast jednej klasy z wieloma nieużywanymi polami.
* Unikanie *redundancji* zmniejsza powtarzalność, a tworzenie wielu podobnych klas utrudnia utrzymanie; przykładem jest jedna klasa `Product` z polem `category` zamiast osobnych klas `BookProduct`, `FoodProduct` i `TechProduct`.

### Komentarze

* Umieszczanie komentarzy w formie *docstrings* pozwala generować dokumentację API, a ich brak utrudnia użytkownikom zrozumienie sposobu korzystania z funkcji; przykładem jest opis parametrów i zwracanej wartości w Pythonie.
* Pisanie komentarzy wyjaśniających *dlaczego* ułatwia zrozumienie decyzji projektowych, a nadmiar komentarzy tłumaczących składnię nie wnosi wartości; przykładem jest komentarz „// użycie algorytmu sortowania szybkiego ze względu na wydajność” zamiast „// pętla for iteruje po elementach”.
* Aktualizowanie komentarzy zapobiega *dezinformacji*, a ich zaniedbanie prowadzi do niezgodności między kodem a opisem; przykładem jest zmiana nazwy funkcji bez poprawienia komentarza, co może zmylić kolejnego programistę.
* Stosowanie komentarzy *TODO* pomaga śledzić zadania do wykonania, a ich brak utrudnia planowanie rozwoju; przykładem jest „// TODO: dodać walidację danych wejściowych”.
* Wyjaśnianie *skomplikowanego kodu* komentarzami ułatwia zrozumienie trudnych fragmentów, a ich brak zmusza do szczegółowej analizy algorytmu; przykładem jest opisanie działania algorytmu dynamicznego programowania w komentarzu nad funkcją.
* Tworzenie *krótkich i zwięzłych* komentarzy poprawia przejrzystość, a nadmiar tekstu utrudnia szybkie przyswajanie informacji; przykładem jest jednozdaniowy opis logiki zamiast wieloakapitu tłumaczenia.
* Pisanie testów w sposób samoopisujący eliminuje potrzebę *komentarzy* w ich treści, a dodatkowe wyjaśnienia sygnalizują słabą czytelność testu; przykładem jest test nazwany `test_calculate_discount_for_senior_customers` zamiast dodawania komentarza „// sprawdza rabat dla seniorów”.

### Obsługa błędów

* Dostosowanie *strategii obsługi błędów* do konkretnego języka zapewnia spójność z jego paradygmatami, a brak tego prowadzi do nieefektywnych lub nietypowych rozwiązań; przykładem jest używanie wyjątków w Javie zamiast konwencji kodów błędów znanych z C.
* Stosowanie *wyjątków* zamiast kodów błędów lub wartości `NULL/None` poprawia czytelność i upraszcza logikę programu, podczas gdy zwracanie kodów wymaga dodatkowej obsługi w każdym wywołaniu; przykładem jest `raise FileNotFoundError` zamiast zwracania `-1`.
* Ograniczenie stosowania *wyjątków* do sytuacji, w których funkcja nie może zakończyć się w przewidywalny sposób, zwiększa przejrzystość kodu, a nadużywanie ich jako kontroli przepływu spowalnia program i utrudnia zrozumienie; przykładem jest zgłaszanie wyjątku przy braku pliku zamiast przy zwykłej iteracji po pustej liście.
* Wyjątki zawierające jasne *informacje* o rodzaju i przyczynie błędu ułatwiają diagnozowanie problemów, a ogólne komunikaty utrudniają debugowanie; przykładem jest `ValueError("Wiek musi być liczbą dodatnią")` zamiast `ValueError("Błąd")`.
* Odpowiednia *obsługa wyjątków* podczas wywoływania funkcji zapobiega awariom, a jej brak prowadzi do nieprzewidzianego zakończenia programu; przykładem jest użycie `try...except` przy otwieraniu pliku, który może nie istnieć.
* Unikanie przekazywania *NULL/None* do funkcji zmniejsza ryzyko błędów wykonania, a poleganie na takich wartościach często prowadzi do `NullPointerException`; przykładem jest stosowanie obiektów opcjonalnych (`Optional` w Javie czy `Option` w Scali) zamiast surowych `null`.

### Struktury danych

* Wybór odpowiedniej *struktury danych* umożliwia efektywne rozwiązanie problemu, a jej nieprzemyślany dobór prowadzi do spadku wydajności; przykładem jest użycie tablicy mieszającej do wyszukiwania elementów zamiast przeszukiwania listy liniowej.
* Korzystanie z *prostych struktur* takich jak listy lub tablice sprawdza się w wielu przypadkach, a ich nadmierne komplikowanie niepotrzebnie zwiększa złożoność; przykładem jest lista przechowująca wyniki pomiarów zamiast drzewa binarnego.
* Użycie *słowników* lub map pozwala na szybki dostęp do danych za pomocą kluczy, a brak takiego rozwiązania wymaga przeszukiwania całej kolekcji; przykładem jest słownik z numerami telefonów przypisanymi do nazwisk.
* Zastosowanie *zbiorów* eliminuje duplikaty i ułatwia sprawdzanie przynależności, a korzystanie z listy w tym celu prowadzi do nadmiarowych danych; przykładem jest zbiór adresów e-mail zapisanych unikalnie.
* W dużych kolekcjach danych *drzewa binarne* lub tablice mieszające przyspieszają wyszukiwanie, a brak ich użycia powoduje znaczny wzrost czasu operacji; przykładem jest drzewo binarne do sortowania elementów w czasie rzeczywistym.
* Stosowanie *kolejek* zapewnia zachowanie kolejności operacji, a ich brak utrudnia przetwarzanie danych w systemach kolejkowych; przykładem jest kolejka zadań w systemie drukowania dokumentów.
* Wykorzystanie *stosów* pozwala na obsługę w modelu LIFO, a użycie innej struktury wymaga dodatkowej logiki; przykładem jest stos do śledzenia wywołań funkcji w czasie działania programu.
* *Krotki* pozwalają przechowywać niemodyfikowalne zestawy wartości, a brak takiej struktury zmusza do używania bardziej rozbudowanych typów; przykładem jest krotka `(x, y)` reprezentująca współrzędne punktu.
* *Listy powiązane* ułatwiają dynamiczne modyfikowanie dużych zbiorów, a brak ich użycia zmusza do kosztownego przesuwania elementów w tablicach; przykładem jest implementacja edytora tekstu przechowującego linie w liście powiązanej.
* Reprezentacja zależności poprzez *grafy* umożliwia analizę złożonych relacji, a brak tej struktury utrudnia modelowanie sieci; przykładem jest graf opisujący połączenia między użytkownikami w mediach społecznościowych.
* *Kolejki priorytetowe* pozwalają na obsługę elementów według określonej wagi, a korzystanie ze zwykłej kolejki wymaga dodatkowego sortowania; przykładem jest system planowania zadań w systemie operacyjnym.

### Testy

* Pisanie *testów jednostkowych* pozwala sprawdzić, czy poszczególne funkcje spełniają swoje cele, a ich brak zwiększa ryzyko ukrytych błędów; przykładem jest test dla funkcji obliczającej podatek od ceny.
* Eliminowanie *duplikacji testów* zapobiega nadmiarowemu sprawdzaniu tego samego scenariusza, a jej brak prowadzi do niepotrzebnie długiego procesu testowania; przykładem jest pojedynczy test sprawdzający poprawność logowania zamiast kilku niemal identycznych przypadków.
* Traktowanie *testów* jako równorzędnych kodowi produkcyjnemu zapewnia wysoką jakość projektu, a ich marginalizowanie skutkuje trudnościami w utrzymaniu; przykładem jest systematyczne aktualizowanie testów wraz ze zmianami w funkcjach.
* Dbanie o *czytelność i organizację* testów ułatwia ich rozumienie i rozwój, a brak struktury powoduje chaos; przykładem jest grupowanie testów w oddzielnych modułach odpowiadających komponentom aplikacji.
* Zapewnienie *szybkości wykonania* testów jednostkowych pozwala na częste ich uruchamianie, a długie testy spowalniają procesy CI/CD; przykładem jest testowanie pojedynczych metod zamiast pełnych procesów biznesowych.
* Tworzenie *niezależnych testów* sprawia, że każdy można uruchomić osobno, a ich zależność prowadzi do trudnych w diagnozie błędów; przykładem jest test bazy danych działający na izolowanym zbiorze danych zamiast współdzielonej instancji.
* Oprócz testów jednostkowych warto stosować *testy integracyjne i akceptacyjne*, które sprawdzają współdziałanie modułów i zgodność z wymaganiami; przykładem jest test pełnego procesu rejestracji użytkownika w aplikacji webowej.
* Unikanie użycia *assert* w kodzie produkcyjnym zmniejsza ryzyko niepożądanego przerwania działania programu, a ich stosowanie poza testami prowadzi do niekontrolowanych awarii; przykładem jest zastąpienie `assert balance >= 0` walidacją z obsługą wyjątku.

## Lista projektów programistycznych

Celem tej sekcji jest zainspirowanie i motywowanie czytelników do aktywnego uczestnictwa w nauce programowania poprzez praktyczne realizowanie różnorodnych projektów. Projekty te różnią się tematyką i stopniem trudności, co pozwala każdemu znaleźć coś dla siebie.

### Szubienica

Projekt gry "Szubienica" polega na odgadywaniu słów. Komputer losowo wybiera słowo z przygotowanej listy, a następnie wyświetla na ekranie serie kresek (_), odpowiadających literom w wybranym słowie. Gracz ma ograniczoną liczbę prób (np. 10) na odgadnięcie całego słowa. W każdej turze gracz wybiera literę. Jeżeli litera jest w słowie, odpowiednie kreski są zastępowane przez tę literę. Jeśli litera nie występuje w słowie, liczba dostępnych prób gracza zmniejsza się o jedną. Gracz wygrywa, jeśli odgadnie wszystkie litery przed wyczerpaniem wszystkich szans.

Projekt ten pozwala na ćwiczenie podstawowych umiejętności programowania, takich jak operacje na łańcuchach znaków, kontrola przepływu programu oraz prosty algorytm losowania. Dodatkowo, można rozbudować grę o różne funkcjonalności, jak np. różne poziomy trudności, podpowiedzi czy graficzne reprezentacje postępów gracza.

#### Linki

<div align="center">

Screenshot | Technologie | Link 
---|---|---
| ![hangman](https://github.com/djeada/Proste-Projekty/assets/37275728/1ce340f4-9efc-423e-a65d-7ee9ac905a9f) | <img src="https://img.icons8.com/color/344/c.png" height="50" /> | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/c/hangman)** |
 ![hangman](https://user-images.githubusercontent.com/37275728/194822831-d1b117cb-ae01-4939-bac1-85ac4e58769a.gif) | <img src="https://img.icons8.com/color/344/python.png" height="50" />  | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/python/hangman)**
 
</div>

### Szyfr Cezara

Projekt Szyfru Cezara to aplikacja umożliwiająca szyfrowanie i deszyfrowanie tekstu przy użyciu jednej z najstarszych znanych metod kryptografii. Interfejs graficzny zawiera pole tekstowe, w którym użytkownik wpisuje tekst do zaszyfrowania lub odszyfrowania. Po wpisaniu tekstu, użytkownik wybiera opcję szyfrowania lub deszyfrowania i podaje wartość klucza przesunięcia, która określa, o ile pozycji w alfabecie przesunąć każdą literę tekstu. Przetworzony tekst jest następnie wyświetlany w interfejsie. Szyfr Cezara jest prostym przykładem szyfru podstawieniowego i jest świetnym sposobem na zrozumienie podstaw kryptografii.

#### Linki

<div align="center">

Screenshot | Technologie | Link 
---|---|---
| ![cipher](https://github.com/djeada/Proste-Projekty/assets/37275728/6f0b1c2f-a948-44e1-96b0-1a1d4b279256) | <img src="https://img.icons8.com/color/344/c.png" height="50" /> | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/c/cipher)** |
![caesar cipher](https://user-images.githubusercontent.com/37275728/194821911-e403023e-c5e5-4b19-b8bb-5cfedae8f164.gif) | <img src="https://img.icons8.com/color/344/python.png" height="50" />  | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/python/caesar_cipher)**
 
</div>

### Kalkulator

Kalkulator to podstawowy projekt, który pomaga w zrozumieniu obsługi interfejsu użytkownika i podstawowych operacji arytmetycznych. Aplikacja pozwala na wykonanie podstawowych operacji matematycznych, takich jak dodawanie, odejmowanie, mnożenie i dzielenie. Interfejs graficzny jest intuicyjny, z przyciskami numerycznymi do wprowadzania liczb oraz przyciskami funkcyjnymi do wyboru operacji. Kalkulator obsługuje zarówno liczby całkowite, jak i zmiennoprzecinkowe, a także wyświetla komunikaty ostrzegawcze w przypadku błędów, takich jak dzielenie przez zero. Ten projekt jest doskonałym sposobem na naukę podstaw obsługi zdarzeń i logiki programistycznej.

#### Linki

<div align="center">
 
Screenshot | Technologie | Link 
---|---|---
| ![calculator](https://github.com/djeada/Proste-Projekty/assets/37275728/e62d057f-bb26-4409-8664-83e7323e1d86) | <img src="https://img.icons8.com/color/344/c.png" height="50" /> | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/c/calculator)** |
![calculator](https://user-images.githubusercontent.com/37275728/194822287-7b84368a-2df0-4f4f-87a0-31951b91a253.gif) | <img src="https://img.icons8.com/color/344/python.png" height="50" />  | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/python/calculator)**
 
</div>

### Lista zadań

Projekt listy zadań to aplikacja do zarządzania zadaniami, która umożliwia użytkownikom tworzenie, edycję, usuwanie oraz sortowanie zadań według różnych kryteriów. Można ustawić priorytety, daty wykonania oraz kategorie dla zadań. Aplikacja umożliwia także dodawanie załączników do zadań, co pozwala na lepsze zorganizowanie pracy. Wszystkie informacje o zadaniach są przechowywane w bazie danych, co ułatwia ich zarządzanie. Aplikacja może również wysyłać powiadomienia o zbliżających się terminach. Ten projekt jest doskonały do nauki pracy z bazami danych, interfejsami użytkownika i systemami powiadamiania.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Pogoda

Projekt aplikacji pogodowej umożliwia użytkownikom sprawdzanie aktualnej pogody oraz prognozy na najbliższe dni dla wybranej lokalizacji. Użytkownik może wprowadzić nazwę miasta lub kod pocztowy, by otrzymać dane takie jak temperatura, wilgotność powietrza, prędkość wiatru, ciśnienie atmosferyczne oraz godziny wschodu i zachodu słońca. Aplikacja zawiera także mapę z zaznaczonymi danymi pogodowymi dla danego regionu. Informacje pogodowe są pobierane z zewnętrznego API, a interfejs użytkownika jest prosty i intuicyjny. Projekt ten pozwala na naukę korzystania z zewnętrznych API, przetwarzania i wyświetlania danych, a także podstaw pracy z mapami.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Stoper

Stoper to prosta aplikacja do odmierzania czasu z dokładnością do milisekund. Posiada funkcjonalności takie jak start, stop, reset oraz możliwość ustawienia czasu, po którym stoper zatrzyma się automatycznie. Użytkownik może wybrać preferowany format wyświetlania czasu i zapisywać wyniki do pliku tekstowego. Interfejs graficzny składa się z przycisków do kontroli stopera oraz wyświetlacza czasu. Jest to doskonały projekt dla początkujących programistów, aby zrozumieć obsługę zdarzeń i pracę z czasem.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| ![timer](https://github.com/djeada/Proste-Projekty/assets/37275728/6923c7e1-1c9e-474c-b106-6491a24f31a4) | <img src="https://img.icons8.com/color/344/c.png" height="50" /> | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/c/timer)** |

### Statki

Gra w statki to klasyczna gra polegająca na umieszczaniu floty na planszy i próbie zatopienia statków przeciwnika. Gracz ustawia swoje statki na planszy, podczas gdy pozycje statków komputera są losowane. Gracze na zmianę wybierają pola, które próbują trafic. Gra oferuje możliwość grania przeciwko komputerowi lub drugiemu graczowi. Projekt ten jest doskonałym ćwiczeniem w programowaniu gier, algorytmach losowania oraz obsłudze zdarzeń użytkownika.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Kółko i krzyżyk

Kółko i krzyżyk to klasyczna gra, która może być realizowana w trybie dwóch graczy lub przeciwko komputerowi. Gracze na zmianę umieszczają swoje symbole (kółko lub krzyżyk) na planszy 3x3. Wygrywa ten, kto pierwszy ustawi trzy swoje symbole w linii. W trybie gry z komputerem, gracz rywalizuje z algorytmem AI. Projekt ten jest świetny do nauki podstaw logiki gier, algorytmów AI i obsługi interfejsu użytkownika.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Saper

Saper to klasyczna gra logiczna, w której zadaniem gracza jest odkrywanie pól na planszy bez detonowania min. Każde pole może zawierać minę lub liczbę wskazującą, ile min sąsiaduje z tym polem. Gracze używają tych liczb, aby bezpiecznie odkrywać kolejne pola. Gracz może także oznaczać pola, na których podejrzewa obecność miny, flagą. Gra kończy się wygraną, gdy wszystkie pola niezawierające min zostaną odkryte. Saper to doskonałe ćwiczenie w logice i strategicznym myśleniu, a także w obsłudze zdarzeń myszy i zarządzaniu stanem gry.

#### Linki
 
<div align="center">

Screenshot | Technologie | Link 
---|---|---
<img width="2000"/>![minesweeper](https://user-images.githubusercontent.com/37275728/194823180-a96946b2-082e-4aac-85cd-e822b6cf58c4.gif) | <img src="https://img.icons8.com/color/344/python.png" height="50" />  | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/python/minesweeper)**
 
</div>

### 2048

2048 to popularna gra logiczna polegająca na łączeniu kafelków z takimi samymi numerami na planszy 4x4. Celem gry jest utworzenie kafelka z liczbą 2048. Gracz przesuwa kafelki w jednym z czterech kierunków, a gdy dwa kafelki o tym samym numerze zderzają się, łączą się w jeden o wartości będącej sumą połączonych kafelków. Po każdym ruchu pojawia się nowy kafelek o wartości 2 lub 4. Gra kończy się, gdy nie ma już możliwości wykonania ruchu lub gracz uzyska kafelek 2048. Projekt 2048 pozwala na naukę programowania animacji, obsługi zdarzeń klawiatury i algorytmów łączenia elementów.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Apokalipsa Zombie

Apokalipsa Zombie to gra akcji, w której celem gracza jest przetrwanie fal atakujących zombie. Z każdą falą, zombie stają się liczniejsze i silniejsze. Gracz musi wykorzystać różnorodne rodzaje broni i bonusy, aby przetrwać i zdobywać punkty. Gra zawiera różne poziomy trudności i umożliwia zdobywanie ulepszeń broni oraz bonusów, takich jak dodatkowe życie czy zwiększenie prędkości. Ten projekt może być interesującym wyzwaniem w zakresie tworzenia gier akcji, z naciskiem na algorytmy sterowania przeciwnikami, detekcję kolizji i zarządzanie zasobami gracza.

#### Linki

<div align="center">

Screenshot | Technologie | Link 
---|---|---
 <img width="2000"/>![zombie_apocalypse](https://user-images.githubusercontent.com/37275728/188334905-179b94fd-eec2-44b8-a64f-fecdd6c6ea01.gif) | <img src="https://img.icons8.com/color/344/python.png" height="50" />  | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/python/zombie_apocalypse)**
 
</div>

### Piętnastka

Piętnastka to klasyczna gra logiczna, w której celem jest ułożenie 15 kwadratów z numerami w kolejności rosnącej na planszy 4x4, zostawiając jedno puste pole, które umożliwia przesuwanie kwadratów. Gracz przesuwa kwadraty wokół pustego pola, aby uzyskać prawidłowe ułożenie. Gra ta jest świetnym ćwiczeniem w algorytmach układania i myślenia przestrzennego. Dodatkowo, implementacja interfejsu użytkownika dla tej gry może pomóc w zrozumieniu obsługi zdarzeń dotykowych lub myszy oraz animacji.

#### Linki
 
<div align="center">

Screenshot | Technologie | Link 
---|---|---
 <img width="2000"/>![fifteen_puzzle](https://user-images.githubusercontent.com/37275728/194822577-fbfa5228-3643-4f61-ad69-bc58cd80b97a.gif) | <img src="https://img.icons8.com/color/344/python.png" height="50" />  | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/python/fifteen_puzzle)**
 
</div>

### Kości

Kości to gra towarzyska, w której gracze rzucają zestawem pięciu kości, starając się uzyskać różne kombinacje przedstawione w tabeli punktacji. Gracz może rzucić kośćmi do trzech razy w swojej turze, aby uzyskać jedną z kombinacji, a następnie zapisuje wynik w swojej tabeli punktów. Kombinacje mogą być użyte tylko raz przez każdego gracza, a na koniec gry zwycięża osoba z najwyższą sumą punktów. Projekt ten jest doskonały do nauki obsługi losowości, zdarzeń i logicznego myślenia, a także oferuje możliwość tworzenia interfejsu użytkownika dla gier planszowych.

#### Linki

<div align="center">

Screenshot | Technologie | Link 
---|---|---
 <img width="2000"/>![yahtzee](https://user-images.githubusercontent.com/37275728/194823845-3aea219e-10d3-4d09-bc36-0832e7e0a8f8.gif) | <img src="https://img.icons8.com/color/344/python.png" height="50" />  | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/python/yahtzee)**
 
</div>

### Kurka wodna

Kurka wodna to dynamiczna gra, w której gracze muszą "ustrzelić" kurki pojawiające się i przelatujące przez ekran, klikając na nie myszką, zanim przekroczą przeciwną stronę ekranu. Z każdą falą, pojawia się więcej kurek, a gra staje się trudniejsza. Projekt ten oferuje wspaniałą okazję do nauki programowania gier zręcznościowych, w tym obsługi zdarzeń myszy, animacji, zarządzania poziomami trudności i implementacji dynamicznych tła oraz elementów graficznych.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Wąż

W grze Wąż gracz steruje wężem poruszającym się po prostokątnej planszy. Cel gry polega na zjadaniu pojawiających się na planszy elementów, co powoduje wydłużanie węża i zdobywanie punktów. Gra staje się trudniejsza w miarę wzrostu węża, ponieważ gracz musi unikać uderzenia głową węża w jego własne ciało. Gra ta jest klasycznym przykładem prostych gier zręcznościowych i świetnie nadaje się do nauki podstaw programowania gier, w tym obsługi ruchu, kolizji oraz zarządzania stanem gry.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| ![snake](https://github.com/djeada/Proste-Projekty/assets/37275728/866797cf-1472-42fd-aca5-c492a684ae44) | <img src="https://img.icons8.com/color/344/c.png" height="50" /> | **[Link](https://github.com/djeada/Proste-Projekty/tree/main/src/c/snake)** |

### Edytor tekstowy

Projekt edytora tekstu oferuje możliwość tworzenia, edytowania i zapisywania tekstów. Użytkownik może również formatować tekst, zmieniając czcionkę, styl i rozmiar, a także dodawać pogrubienie, kursywę i podkreślenie. Jest to doskonałe ćwiczenie w obsłudze zdarzeń klawiatury, interfejsu użytkownika oraz podstawowych technik formatowania tekstu. Może również obejmować funkcjonalności takie jak wybór kolorów tekstu, listy punktowane czy wstawianie obrazów.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Obróbka grafiki

Program do obróbki grafiki umożliwia importowanie, wyświetlanie oraz edycję obrazów w formatach PNG i JPG. Użytkownik może korzystać z różnych narzędzi, takich jak rotacja, przycinanie, rozciąganie, zmiana koloru, gumka, zaznaczanie i pędzel. Projekt ten jest doskonałą okazją do nauki obsługi plików graficznych, implementacji narzędzi edycyjnych oraz podstaw grafiki komputerowej. Można również rozszerzyć projekt o bardziej zaawansowane funkcje, takie jak warstwy, filtry czy efekty specjalne.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### System kontroli wersji

Projekt systemu kontroli wersji oferuje podstawową funkcjonalność zarządzania wersjami projektu. Pozwala użytkownikowi na zapisywanie bieżącego stanu projektu i przeglądanie historii zapisów. Dzięki temu można łatwo przywracać wcześniejsze wersje projektu lub cofać wprowadzone zmiany. Jest to doskonałe ćwiczenie w zakresie zarządzania plikami, obsługi systemów plików oraz podstaw algorytmów związanych z kontrolą wersji.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Serwer HTTP

Projekt serwera HTTP polega na stworzeniu serwera, który nasłuchuje na żądania HTTP wysyłane do adresu URL, np. http://127.0.0.1:8000/, i zwraca odpowiedzi. Serwer może obsługiwać różne typy żądań, takie jak GET, POST, PUT i DELETE. W przypadku żądania GET, serwer może zwracać strony HTML, obrazy, pliki JSON lub inne typy plików. Serwer może być także połączony z bazą danych, umożliwiając tworzenie dynamicznych aplikacji internetowych z funkcjami odczytu i zapisu danych. Projekt ten jest doskonałym wprowadzeniem do programowania serwerowego, sieci i protokołów HTTP.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Koszyk z zakupami

Projekt koszyka z zakupami to aplikacja e-commerce, która umożliwia użytkownikowi dodawanie produktów do koszyka, usuwanie ich oraz zmianę ich ilości. Aplikacja umożliwia również stosowanie kodów rabatowych i prowadzenie przez proces zakupowy. Produkty są prezentowane w atrakcyjny sposób, z obrazkami i informacjami o cenach. Projekt ten pozwala na naukę tworzenia interfejsów użytkownika, zarządzania stanem aplikacji oraz integracji z systemami płatności i bazami danych.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Zamawianie jedzenia

Aplikacja do zamawiania jedzenia pozwala użytkownikom przeglądać menu z dostępnymi daniami, wraz z ich zdjęciami, cenami, opisami i kategoriami. Po wybraniu posiłku, użytkownik podaje adres dostawy i wybiera formę płatności - PayPal, karta kredytowa lub gotówka przy odbiorze. Aplikacja może również zawierać funkcję śledzenia statusu zamówienia w czasie rzeczywistym. Jest to kompleksowy projekt, który łączy w sobie zarządzanie bazą danych, interfejs użytkownika, obsługę płatności oraz integrację z zewnętrznymi usługami dostarczania.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

### Komunikator internetowy

Komunikator internetowy to aplikacja umożliwiająca komunikację tekstową, przesyłanie plików i wideorozmowy między użytkownikami. W prostszej wersji, użytkownicy mogą komunikować się w sieci LAN, a w bardziej zaawansowanej wersji - z dowolnym miejscem na świecie przez internet. Funkcje takie jak tworzenie kont, zarządzanie listą kontaktów i szyfrowanie komunikacji mogą zostać dodane, by zwiększyć funkcjonalność i bezpieczeństwo. Projekt ten oferuje praktyczne doświadczenie w pracy z sieciami, protokołami komunikacyjnymi oraz zabezpieczeniami danych.

#### Linki

Screenshot | Technologie | Link 
---|---|---
| - | - | - |

## Szablony projektów

W repozytorium znajdziesz gotowe szablony projektów dla najpopularniejszych technologii:

- [Szablon Vanilla JavaScript](dodatkowe_materialy/szablony_projektow/vanilla_javascript/) – frontendowy projekt w czystym JS
- [Szablon C z CMake](dodatkowe_materialy/szablony_projektow/c_cmake/) – projekt w języku C z automatyzacją budowania i testów
- [Szablon Python (setup.py + Nuitka)](dodatkowe_materialy/szablony_projektow/python_setup_py/) – projekt w Pythonie z wsparciem dla kompilacji binarnej

Każdy szablon zawiera:
- Opis po polsku
- Przykładową strukturę katalogów
- Konfigurację narzędzi do testowania, lintowania, formatowania i deploymentu
- Przykładowe pliki konfiguracyjne i workflow CI

**Uwaga:**
- Pliki README i opisy w szablonach są po polsku, aby ułatwić start osobom początkującym.
- Właściwe projekty dostępne w katalogu [`src/`](src/) mają dokumentację i kod po angielsku, by były bardziej dostępne dla społeczności międzynarodowej.

Aby rozpocząć własny projekt, skopiuj wybrany szablon i postępuj zgodnie z instrukcjami w README danego szablonu.

## Dodatkowe materiały

W tej sekcji znajdziesz przydatne materiały, które pomogą Ci w nauce, planowaniu i realizacji własnych projektów:

### Szablony projektów
- [Szablon Vanilla JavaScript](dodatkowe_materialy/szablony_projektow/vanilla_javascript/) – nowoczesny frontend JS
- [Szablon C z CMake](dodatkowe_materialy/szablony_projektow/c_cmake/) – projekt w C z automatyzacją
- [Szablon Python (setup.py + Nuitka)](dodatkowe_materialy/szablony_projektow/python_setup_py/) – Python z kompilacją binarną

### Przykłady specyfikacji projektów
- [Functional specification – Wikipedia](https://en.wikipedia.org/wiki/Functional_specification)
- [Challenging projects – blog](https://web.eecs.utk.edu/~azh/blog/challengingprojects.html)
- [The Odin Project – ścieżki projektowe](https://www.theodinproject.com/paths/full-stack-javascript)
- [KTH – projekty inżynierskie](https://people.kth.se/~johanmon/dse.html)
- [Przykładowa specyfikacja (gist)](https://gist.github.com/MWins/41c6fec2122dd47fdfaca31924647499)
- [DJ4E – przegląd projektów](https://www.dj4e.com/project/00_overview.md)
- [Rutgers – projekty SE](https://www.ece.rutgers.edu/~marsic/books/SE/projects/)
- [Stanford – projekty C](http://cslibrary.stanford.edu/112/)
- [Minesweeper – projekt PDF](https://itp.uni-frankfurt.de/~mwagner/teaching/C_WS17/projects/Minesweeper.pdf)

### Przykłady dobrych plików README
- [Portfolio template](https://github.com/alecortega/portfolio-template)
- [Best-README-Template](https://github.com/othneildrew/Best-README-Template)

### Inspiracje i pełne implementacje projektów
- [Python mini-projects](https://github.com/Python-World/python-mini-projects) – zbiór małych projektów w Pythonie
- [C# Data Visualization](https://github.com/swharden/Csharp-Data-Visualization) – wizualizacje danych w C#
- [Project-based learning](https://github.com/practical-tutorials/project-based-learning) – projekty do nauki przez praktykę
- [50 Projects 50 Days](https://github.com/bradtraversy/50projects50days) – 50 małych projektów webowych

### Inne przydatne zasoby
- [Nauka programowania – repozytorium z ćwiczeniami](https://github.com/djeada/Nauka-Programowania)
- [Stack Overflow](https://stackoverflow.com/) – pytania i odpowiedzi programistyczne
- [VS Code](https://code.visualstudio.com/) – edytor kodu
- [Heroku](https://devcenter.heroku.com/) – darmowy hosting aplikacji webowych

Jeśli masz własne propozycje ciekawych materiałów lub chcesz podzielić się swoim projektem, otwórz issue lub pull request!
